---
title: Facts and Fallacies in Software Engineering
date: "2006-08-22T12:00:00Z"
categories:
  - links
wp_id: 254
---

[Facts in Software Engineering](http://www.informit.com/articles/article.asp?p=30091&rl=1)

**People**

1. The most important factor in software work is the quality of the programmers.
2. The best programmers are up to 28 times better than the worst programmers.
3. Adding people to a late project makes it later.
4. The working environment has a profound impact on productivity and quality.

**Tools and Techniques**

5. Hype (about tools and techniques) is the plague on the house of software.
6. New tools/techniques cause an initial loss of productivity/quality.
7. Software developers talk a lot about tools, but seldom use them.

**Estimation**

8. One of the two most common causes of runaway projects is poor estimation.
9. Software estimation usually occurs at the wrong time.
10. Software estimation is usually done by the wrong people.
11. Software estimates are rarely corrected as the project proceeds.
12. It is not surprising that software estimates are bad. But we live and die by them anyway!
13. There is a disconnect between software management and their programmers.
14. The answer to a feasibility study is almost always "yes".

**Reuse**

15. Reuse-in-the-small is a well-solved problem.
16. Reuse-in-the-large remains a mostly unsolved problem.
17. Reuse-in-the-large works best for families of related systems.
18. Reusable components are three times as hard to build, and should be tried out in three settings.
19. Modification of reused code is particularly error-prone.
20. Design pattern reuse is one solution to the problems of code reuse.

**Complexity**

21. For every 25 percent increase in problem complexity, there is a 100 percent increase in solution complexity.
22. Eighty percent of software work is intellectual. A fair amount of it is creative. Little of it is clerical.

**Requirements**

23. One of the two most common causes of runaway projects is unstable requirements.
24. Requirements errors are the most expensive to fix during production.
25. Missing requirements are the hardest requirements errors to correct.

**Design**

26. Explicit requirements "explode" as implicit (design) requirements for a solution evolve.
27. There is seldom one best design solution to a software problem.
28. Design is a complex, iterative process. Initial design solutions are usually wrong, and certainly not optimal.

**Coding**

29. Designer "primitives" (solutions they can readily code) rarely match programmer "primitives".
30. COBOL is a very bad language, but all the others (for business applications) are so much worse.

**Error-removal**

31. Error-removal is the most time-consuming phase of the life cycle.

**Testing**

32. Software is usually tested at best at the 55-60 percent (branch) coverage level.
33. 100 percent coverage is still far from enough.
34. Test tools are essential, but many are rarely used.
35. Test automation rarely is. Most testing activities cannot be automated.
36. Programmer-created, built-in, debug code is an important supplement to testing tools.

**Reviews/Inspections**

37. Rigorous inspections can remove up to 90 percent of errors before the first test case is run.
38. But rigorous inspections should not replace testing.
39. Post-delivery reviews (some call them "retrospectives") are important, and seldom performed.
40. Reviews are both technical and sociological, and both factors must be accommodated.

**Maintenance**

41. Maintenance typically consumes 40-80 percent of software costs. It is probably the most important life cycle phase of software.
42. Enhancements represent roughly 60 percent of maintenance costs.
43. Maintenance is a solution, not a problem.
44. Understanding the existing product is the most difficult task of maintenance.
45. Better methods lead to MORE maintenance, not less.

**Quality**

46. Quality IS: a collection of attributes.
47. Quality is NOT: user satisfaction, meeting requirements, achieving cost/schedule, or reliability.

**Reliability**

48. There are errors that most programmers tend to make.
49. Errors tend to cluster.
50. There is no single best approach to software error removal.
51. Residual errors will always persist. The goal should be to minimize or eliminate severe errors.

**Efficiency**

52. Efficiency stems more from good design than good coding.
53. High-order-language code can be about 90 percent as efficient as comparable assembler code.
54. There are tradeoffs between size and time optimization.

**About Research**

55. Many researchers advocate rather than investigate.

[Fallacies in Software Engineering](http://www.informit.com/articles/article.asp?p=30032&rl=1)

**About Management**

1. Fallacy: You can't manage what you can't measure.
2. Fallacy: You can manage quality into a software product.

**People**

3. Fallacy: Programming can and should be egoless.

**Tools and Techniques**

4. Fallacy: Tools and techniques: one size fits all.
5. Fallacy: Software needs more methodologies.

**Estimation**

6. Fallacy: To estimate cost and schedule, first estimate lines of code.

**Testing**

7. Fallacy: Random test input is a good way to optimize testing.

**Reviews**

8. Fallacy: "Given enough eyeballs, all bugs are shallow".

**Maintenance**

9. Fallacy: The way to predict future maintenance cost and to make product replacement decisions is to look at past cost data.

**About Education**

10. Fallacy: You teach people how to program by showing them how to write programs.

These are from Robert Glass' book [Facts and Fallacies in Software Engineering](http://www.amazon.com/gp/product/0321117425/?tag=sanand-20).
